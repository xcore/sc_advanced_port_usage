// Copyright (c) 2011, XMOS Ltd, All rights reserved
// This software is freely distributable under a derivative of the
// University of Illinois/NCSA Open Source License posted in
// LICENSE.txt and at <http://github.xcore.com/>

#include <xs1.h>
#include <print.h>
#include <stdio.h>
#include "zip.h"

static unsigned zipLookup[256] = {
    0x00000000, 0x00000001, 0x00000010, 0x00000011,
    0x00000100, 0x00000101, 0x00000110, 0x00000111,
    0x00001000, 0x00001001, 0x00001010, 0x00001011,
    0x00001100, 0x00001101, 0x00001110, 0x00001111,
    0x00010000, 0x00010001, 0x00010010, 0x00010011,
    0x00010100, 0x00010101, 0x00010110, 0x00010111,
    0x00011000, 0x00011001, 0x00011010, 0x00011011,
    0x00011100, 0x00011101, 0x00011110, 0x00011111,
    0x00100000, 0x00100001, 0x00100010, 0x00100011,
    0x00100100, 0x00100101, 0x00100110, 0x00100111,
    0x00101000, 0x00101001, 0x00101010, 0x00101011,
    0x00101100, 0x00101101, 0x00101110, 0x00101111,
    0x00110000, 0x00110001, 0x00110010, 0x00110011,
    0x00110100, 0x00110101, 0x00110110, 0x00110111,
    0x00111000, 0x00111001, 0x00111010, 0x00111011,
    0x00111100, 0x00111101, 0x00111110, 0x00111111,
    0x01000000, 0x01000001, 0x01000010, 0x01000011,
    0x01000100, 0x01000101, 0x01000110, 0x01000111,
    0x01001000, 0x01001001, 0x01001010, 0x01001011,
    0x01001100, 0x01001101, 0x01001110, 0x01001111,
    0x01010000, 0x01010001, 0x01010010, 0x01010011,
    0x01010100, 0x01010101, 0x01010110, 0x01010111,
    0x01011000, 0x01011001, 0x01011010, 0x01011011,
    0x01011100, 0x01011101, 0x01011110, 0x01011111,
    0x01100000, 0x01100001, 0x01100010, 0x01100011,
    0x01100100, 0x01100101, 0x01100110, 0x01100111,
    0x01101000, 0x01101001, 0x01101010, 0x01101011,
    0x01101100, 0x01101101, 0x01101110, 0x01101111,
    0x01110000, 0x01110001, 0x01110010, 0x01110011,
    0x01110100, 0x01110101, 0x01110110, 0x01110111,
    0x01111000, 0x01111001, 0x01111010, 0x01111011,
    0x01111100, 0x01111101, 0x01111110, 0x01111111,
    0x10000000, 0x10000001, 0x10000010, 0x10000011,
    0x10000100, 0x10000101, 0x10000110, 0x10000111,
    0x10001000, 0x10001001, 0x10001010, 0x10001011,
    0x10001100, 0x10001101, 0x10001110, 0x10001111,
    0x10010000, 0x10010001, 0x10010010, 0x10010011,
    0x10010100, 0x10010101, 0x10010110, 0x10010111,
    0x10011000, 0x10011001, 0x10011010, 0x10011011,
    0x10011100, 0x10011101, 0x10011110, 0x10011111,
    0x10100000, 0x10100001, 0x10100010, 0x10100011,
    0x10100100, 0x10100101, 0x10100110, 0x10100111,
    0x10101000, 0x10101001, 0x10101010, 0x10101011,
    0x10101100, 0x10101101, 0x10101110, 0x10101111,
    0x10110000, 0x10110001, 0x10110010, 0x10110011,
    0x10110100, 0x10110101, 0x10110110, 0x10110111,
    0x10111000, 0x10111001, 0x10111010, 0x10111011,
    0x10111100, 0x10111101, 0x10111110, 0x10111111,
    0x11000000, 0x11000001, 0x11000010, 0x11000011,
    0x11000100, 0x11000101, 0x11000110, 0x11000111,
    0x11001000, 0x11001001, 0x11001010, 0x11001011,
    0x11001100, 0x11001101, 0x11001110, 0x11001111,
    0x11010000, 0x11010001, 0x11010010, 0x11010011,
    0x11010100, 0x11010101, 0x11010110, 0x11010111,
    0x11011000, 0x11011001, 0x11011010, 0x11011011,
    0x11011100, 0x11011101, 0x11011110, 0x11011111,
    0x11100000, 0x11100001, 0x11100010, 0x11100011,
    0x11100100, 0x11100101, 0x11100110, 0x11100111,
    0x11101000, 0x11101001, 0x11101010, 0x11101011,
    0x11101100, 0x11101101, 0x11101110, 0x11101111,
    0x11110000, 0x11110001, 0x11110010, 0x11110011,
    0x11110100, 0x11110101, 0x11110110, 0x11110111,
    0x11111000, 0x11111001, 0x11111010, 0x11111011,
    0x11111100, 0x11111101, 0x11111110, 0x11111111,
};

void outputWordsZipped(buffered out port:32 p, int d, int c, int b, int a) {
#pragma unsafe arrays
#pragma loop unroll
    for(int i = 0; i < 4; i++) {
        int bits = zipLookup[a & 0xff];
        bits = bits << 1 | zipLookup[b & 0xff];
        bits = bits << 1 | zipLookup[c & 0xff];
        bits = bits << 1 | zipLookup[d & 0xff];
        p <: bits;
        a >>= 8;
        b >>= 8;
        c >>= 8;
        d >>= 8;
    }
}

static unsigned char unzipLookup[256] = {
    0x3a,0xfb,0x91,0x50,0x98,0x59,0x33,0xf2,
    0x5b,0x9a,0xf0,0x31,0xf9,0x38,0x52,0x93,
    0x79,0xb8,0xd2,0x13,0xdb,0x1a,0x70,0xb1,
    0x18,0xd9,0xb3,0x72,0xba,0x7b,0x11,0xd0,
    0xad,0x6c,0x06,0xc7,0x0f,0xce,0xa4,0x65,
    0xcc,0x0d,0x67,0xa6,0x6e,0xaf,0xc5,0x04,
    0xee,0x2f,0x45,0x84,0x4c,0x8d,0xe7,0x26,
    0x8f,0x4e,0x24,0xe5,0x2d,0xec,0x86,0x47,
    0xbf,0x7e,0x14,0xd5,0x1d,0xdc,0xb6,0x77,
    0xde,0x1f,0x75,0xb4,0x7c,0xbd,0xd7,0x16,
    0xfc,0x3d,0x57,0x96,0x5e,0x9f,0xf5,0x34,
    0x9d,0x5c,0x36,0xf7,0x3f,0xfe,0x94,0x55,
    0x28,0xe9,0x83,0x42,0x8a,0x4b,0x21,0xe0,
    0x49,0x88,0xe2,0x23,0xeb,0x2a,0x40,0x81,
    0x6b,0xaa,0xc0,0x01,0xc9,0x08,0x62,0xa3,
    0x0a,0xcb,0xa1,0x60,0xa8,0x69,0x03,0xc2,
    0xf8,0x39,0x53,0x92,0x5a,0x9b,0xf1,0x30,
    0x99,0x58,0x32,0xf3,0x3b,0xfa,0x90,0x51,
    0xbb,0x7a,0x10,0xd1,0x19,0xd8,0xb2,0x73,
    0xda,0x1b,0x71,0xb0,0x78,0xb9,0xd3,0x12,
    0x6f,0xae,0xc4,0x05,0xcd,0x0c,0x66,0xa7,
    0x0e,0xcf,0xa5,0x64,0xac,0x6d,0x07,0xc6,
    0x2c,0xed,0x87,0x46,0x8e,0x4f,0x25,0xe4,
    0x4d,0x8c,0xe6,0x27,0xef,0x2e,0x44,0x85,
    0x7d,0xbc,0xd6,0x17,0xdf,0x1e,0x74,0xb5,
    0x1c,0xdd,0xb7,0x76,0xbe,0x7f,0x15,0xd4,
    0x3e,0xff,0x95,0x54,0x9c,0x5d,0x37,0xf6,
    0x5f,0x9e,0xf4,0x35,0xfd,0x3c,0x56,0x97,
    0xea,0x2b,0x41,0x80,0x48,0x89,0xe3,0x22,
    0x8b,0x4a,0x20,0xe1,0x29,0xe8,0x82,0x43,
    0xa9,0x68,0x02,0xc3,0x0b,0xca,0xa0,0x61,
    0xc8,0x09,0x63,0xa2,0x6a,0xab,0xc1,0x00,
};

{int,int,int,int} inputWordsZipped(buffered in port:32 p) {
    unsigned mask = 0x11111111;
    unsigned a = 0, b = 0, c = 0, d = 0;
#pragma unsafe arrays
#pragma loop unroll
    for(int i = 0; i < 4; i++) {
        unsigned bits, residual;
        p :> bits;
        residual = bits & mask;
        crc32(residual, 0xFF, 0xE0);
        a = a<<8 | unzipLookup[residual];
        bits >>= 1;
        residual = bits & mask;
        crc32(residual, 0xFF, 0xE0);
        b = b<<8 | unzipLookup[residual];
        bits >>= 1;
        residual = bits & mask;
        crc32(residual, 0xFF, 0xE0);
        c = c<<8 | unzipLookup[residual];
        bits >>= 1;
        residual = bits & mask;
        crc32(residual, 0xFF, 0xE0);
        d = d<<8 | unzipLookup[residual];
    }
    return {a,b,c,d};
}

#if 0
void all() {
    for(int i = 0; i < 256; i++) {
        unsigned k = zipLookup[i];
        crc32(k, 0xFF, 0xE0);
        unzipLookup[k] = i;
    }
    for(int i = 0; i < 256; i++) {
        printf("0x%02x,",unzipLookup[i]);
        if ((i & 7)==7) printf("\n");
    }
}
#endif
